---
title: 7. Стінки
weight: 7
---
# Стінки

В цій грі потрібні 2 типи стінок, одні, вгорі і внизу поля, просто відбиватимуть м'яч. Інші, позаду кожного з гравців, зараховуватимуть поразку кожному з них та стартуватимуть новий раунд. 
Почнемо зі стінок відбивання. 
Тут все досить просто. Нам знову потрібен вузол класу `Area2D`, який виявлятиме зіткнення з м'ячем та відбиватиме його. 
Для цього натискаємо правою на вузол `Main` та створюємо новий вузол класу `Area2D`. Перейменуємо його на `Wall`. Далі додаємо до нього `CollisionShape2D` та визначаємо форму прямокутника. Розтягуємо колайдер, так щоб він був трохи ширший ніж вікно. Далі розміщаємо його на верхньому краю вікна. 

{{< video autoplay="true" muted="true" loop="true" src="PongWall" >}} 

Стіна повинна мати невеличкий шматочок коду, щоб реагувати на зіткнення. Тож, виділяємо об'єкт `Wall` та внизу інспектора створюємо новий сценарій.
Тепер перемикаємось на вкладку `Node` на правій панелі, щоб знову попрацювати з сигналами. Підєднуємо все той же `area_entered` сигнал до самого вузла `Wall`.

{{< video autoplay="true" muted="true" loop="true" src="PongWallSignal" >}} 

Для початку в тілі цієї нової функції перевіряємо, чи зіткнення відбулось саме з м'ячем. Як ми вже це робили:

{{< highlight GDScript >}} 
if area.name == "Ball":
{{< / highlight >}}
А зараз, все що нам потрібно зробити, це інвертувати значення напрямку руху по осі `y`. Отже, отримаємо:

{{< highlight GDScript >}} 
func _on_wall_area_entered(area):
	if area.name == "Ball":
		area.direction.y = -area.direction.y

{{< / highlight >}}
Зараз просто здублюємо цю стіну, та перемістимо копію вниз екрану. Для цього виділяємо об'єкт `Wall` та натискаємо `Ctrl+D`. Потім мишкою або стірлками на клавіатурі переміщаємо нову копію вниз.

{{< video autoplay="true" muted="true" loop="true" src="PongWallDupMove" >}} 

Зараз, коли є стінки відбивання, ми вже можемо вирішити питання напрямку відбивання м'яча дощечками. Поки він рухався тільки по осі x, що робить цю гру не особливо цікавою. 
Щоб вирішити це, нам потрібно відхиляти м'ячик після зіткнення з дощечкою. Для цього ми скористаємось генератором випадкових чисел. А саме, функцією, яка генерує число з плаваючою точкою від 0 до 1. Повертаємось до коду дощечки. Як новий напрямок руху м'яча досі ми передавали вектор, друге значення якого рівне 0. Сюди ми і вліпимо наше випадкове число. Але якщо ми його залишимо як є, то відбивання завжди відхилятиме в одну сторону, бо, як я говорив, генерується число від 0 до 1. А нам треба, щоб було між -1 і 1. Тому, домножуємо наше випадкове число на 2 та віднімаємо 1. Рядок виглядатиме ось так:

{{< highlight GDScript >}} 
area.direction = Vector2(_ball_dir, randf() * 2 - 1)
{{< / highlight >}}
Цей рядок все ще має дві проблеми. Перша це те, що вектор кожен раз має різну довжину, а це впливатиме на швидкість руху м'яча. Нам цього не потрібно. 
Щоб уникнути цієї проблеми, нам треба якийсь спосіб зафіксувати довжину вектора. Такий процес називається нормалізацією. Тобто, отримання вектора, напрям якого ідентичний нашому, але довжина завжди рівна одиниці. Нормалізація, це метод самого вектора. Тож, наш рядок виглядатиме таким чином:

{{< highlight GDScript >}} 
area.direction = Vector2(_ball_dir, randf() * 2 - 1).normalized()
{{< / highlight >}}

Друга наша проблема, це те, як працює генератор випадкових чисел, чи точніше псевдо-випадкових чисел. 
Комп'ютер не вміє генерувати справжнє випадкове число. Він використовує алгоритми, які генерують нескінченний рід чисел, які схожі на випадкові. Така функція-генератор бере на вхід певне ціле число, що називається зерном генерації. І якщо ви повторно використаєте те саме зерно, ви отримаєте ідентичну послідовність чисел. 
Щоб проілюструвати цю проблему, видрукуємо кожне випадкове число, яке генерується після зіткнення, та пограємо гру кілька разів. Для цього допишемо:

{{< highlight GDScript >}} 
print(randf())
{{< / highlight >}}
відразу після нашого попереднього рядка. 

Ось що ми можемо побачити після двох ігор:

![Image](/images/Random01.jpg)  

Як бачите, послідовності ідентичні. 
Щоб це вирішити, існує інструмент, який бере значення часу в момент виконання, та використовує його як зерно. Таким чином, при кожному запуску гри ми матимемо різне зерно і різні послідовності псевдо-випадкових чисел. 
Для цього нам лише потрібно в тілі функції `_ready()` додати рядок

{{< highlight GDScript >}} 
randomize()
{{< / highlight >}}
Зараз, скільки б ми не запускали гру, послідовність буде різною і гра буде різною кожен раз.

Майже все готово, щоб можна було і справді пограти в цю гру. Нам залишилось вести рахунок. Далі ми цим і займемось. 

