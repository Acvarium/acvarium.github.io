---
title: 8. Рахунок
weight: 8
---
# Рахунок
Почнемо з того, що ми вже добре вміємо, до вузла `Main` додамо новий вузол `Area2D`, до нього відразу колайдер, який розтягнемо, щоб він перекривав лівий вихід для кулі, позаду лівого гравця. Перейменуємо вузол на `LeftWall`. Далі здублюємо, копію переміщаємо вправо, позаду правого гравця і перейменовуємо `RightWall`. 

{{< video autoplay="true" muted="true" loop="true" src="PongLeftRightWalls" >}} 

Сигнали цього разу будемо під'єднувати до вузла `Main`. Але він поки немає коду. Тож створимо для нього новий сценарій. 

Зараз по черзі приєднаємо сигнал `area_entered` від кожної з нових стінок до вузла `Main`. При цьому кожен з сигналів матиме окрему функцію, так щоб ми знали, куди саме перейшов м'ячик. 

{{< video autoplay="true" muted="true" loop="true" src="PongLRWallSignals" >}} 

Далі в сценарії `Main` відразу під першим рядком додамо дві змінні, які зберігатимуть рахунок гри для кожного з гравців. 


{{< highlight GDScript >}}
var left_score = 0
var right_score = 0
{{< / highlight >}}


Створимо функцію, яка буде показувати рахунок гри. Поки що у нас немає ніяких текстових елементів, тож, виводити будемо просто в вікно `Output`. Для цього є зручна функція `print()`.
Отже, функція виводу рахунку буде виглядати так:

{{< highlight GDScript >}} 
func show_score():
	print(left_score, ":", right_score)
{{< / highlight >}}

Наступною у нас буде функція, яка зараховуватиме переможні бали та викликатиме їх вивід. Вона прийматиме значення напрямку, де якщо воно рівно -1, то переміг лівий, а якщо 1, то правий.

{{< highlight GDScript >}} 
func goal(dir):
	if dir < 0:
		left_score += 1
	else:
		right_score += 1
	show_score()
{{< / highlight >}}

Зараз ми вже можемо в функції, які опрацьовують сигнали зіткнень, дописати виклик функції `goal()`. Додатково, як завжди, зробимо перевірку, чи зіткнення було саме з м'ячем:

{{< highlight GDScript >}} 
func _on_LeftWall_area_entered(area):
	if area.name == "Ball":
		goal(1)


func _on_RightWall_area_entered(area):
	if area.name == "Ball":
		goal(-1)
{{< / highlight >}}

Залишилась одна проблема, наш м'яч після зіткнення з боковими стінками вилітає і ніколи не повертається. Але в цім випадку має початись новий раунд. Тож, переходимо в сценарій `ball` та створюємо функцію `reset()`. 

Вона повинна робити три речі. По переш, повертати м'ячик в початкову позицію посередині екрану. По друге, повертати швидкість на початкове значення, оскільки ми її поступово збільшуємо впродовж раунду. По третє, відправляти його в напрямку гравця, який щойно пропустив. 
Для вирішення першої створюємо нову глобальну змінну, де буде зберігатись початкова позиція м'яча. Зчитати цю позицію ми зможемо тільки коли вузол повністю додано в сцену, тому починаємо з ключового слова `onready`. Виходить:

{{< highlight GDScript >}} 
onready var _initial_pos = position
{{< / highlight >}}

Тепер в тілі функції `reset()` ми можемо дописати:

{{< highlight GDScript >}} 
position = _initial_pos
{{< / highlight >}}

Для вирішення другої проблеми, проблеми з швидкістю, дописуємо в цю ж функцію рядок:

{{< highlight GDScript >}} 
_speed = DEFAULT_SPEED
{{< / highlight >}}

Залишається третя проблема, напрямок руху.
По суті, нам треба занулити другу величину вектора напрямку. Тобто, напрямок по осі `x` залишається незмінним, а по вертикалі буде рівний нулю.
Це досить легко зробити просто домноживши вектор `direcrion` на новий вектор `Vector2(1,0)`. Там де одиниця, величина не зміниться, а там де нуль, вона стане рівна нулю. 
Одна проблема з цим методом, що довжина вектора знову змінилась, і це вплине на швидкість руху. Тому просто беремо цей вираз в дужки і нормалізуємо. 
Ось що має получитись:

{{< highlight GDScript >}} 
direction = (direction * Vector2(1,0)).normalized()
{{< / highlight >}}

І вся функція `reset()` повинна виглядати ось так:

{{< highlight GDScript >}} 
func reset():
	position = _initial_pos
	_speed = DEFAULT_SPEED
	direction = (direction * Vector2(1,0)).normalized()
{{< / highlight >}}

Повертаємось до сценарію `Main` та в кожну функцію, що опрацьовує зіткнення додаємо по рядку:

{{< highlight GDScript >}} 
area.reset()
{{< / highlight >}}

Після всіх змін, сценарій `Main` повинен виглядати ось так:

{{< highlight GDScript >}} 
extends Node2D

var left_score = 0
var right_score = 0

func show_score():
	print(left_score, ":", right_score)
	

func goal(dir):
	if dir < 0:
		left_score += 1
	else:
		right_score += 1
	show_score()
	

func _on_LeftWall_area_entered(area):
	if area.name == "Ball":
		goal(1)
		area.reset()


func _on_RightWall_area_entered(area):
	if area.name == "Ball":
		goal(-1)
		area.reset()
{{< / highlight >}}

Зараз ми вже можемо запустити гру та розпочати поєдинок. 
Цей проект ми поки залишаємо. Візуалізація рахунку гри та взагалі оформлення користувацького інтерфейсу буде детальніше розглянута з наступним проектом. А всім хто дійшов до цієї точки, пропоную самостійно покращити вигляд гри, намалювавши зображення для дощечок, кульки та ігрового поля. 
Ось що у мене получилось:

![Image](/images/PongFin.jpg)  

Нижче ви можете завантажити готовий і відчищений проект цієї гри:

[pong_fin.zip](/download/pong_fin.zip)

