---
title: 4. Перша ракетка
weight: 4
---

# Перша ракетка

Гра, яку ми сьогодні побудуємо, носить назву Pong. Це дуже проста і одна з найстаріших комп'ютерних ігор. Вона з'явилась ще в 1972 році. Гра передбачає 2 гравці, і, по суті своїй, дуже схоже на настільний теніс. Кожен з гравців керує однією з дощечок. Її можна рухати вверх або вниз і за її допомогою гравець має відбивати кульку.  
Почнемо з створення дощечок. Для цього натискаємо правою кнопкою на наш кореневий вузол і натискаємо Add Child Node (додати дочірній вузол). Нас цікавить вузол під назвою `Area2D`. 

![Image](/images/NodeArea2D.jpg)  

Його особливість в тому, що він надсилає сигнал, як тільки зафіксував дотик з фізичним об'єктом. Це нам дозволить виявляти зіткнення кульки з дощечкою. 

В полі пошуку набираємо "area" і бачимо синій значок `Area2D`.

Наш новий вузол поки невидимий. Все що ми можемо побачити, це хрестик в центрі координат. Це буде ліва дощечка, тож назвемо вузол Left.

![Image](/images/NodeArea2D02.jpg)  

Знак оклику поряд означає, що чогось не вистачає. В цьому випадку нам потрібен колайдер. Тобто тіло, форма якого визначає зіткнення.
Натискаємо правою, додати дочірній вузол, в полі пошуку набираємо "Coll". Внизу синенький значок `CollisionShape2D`.

![Image](/images/NodeCollision.jpg)  

Знову знак оклику. Цього разу він каже, що нам треба обрати форму для колайдера. В інспекторі натискаємо навпроти форми. Тут є вибір різних примітивів. Нас цікавить прямокутник.
Ще раз натисніть на вибрану форму, і ви зможете змінити її розміри.
Давайте задамо 10 на 50 пікселів.

{{< video autoplay="true" muted="true" loop="true" src="CollShape01" >}}

Далі з виділеним колайдером на панелі вгорі знайдіть кнопочку з замочком. Натисніть її. Це запобіжний захід, щоб ми випадково не змістили сам колайдер, а рухали тільки саму дощечку.

![Image](/images/LockButton.jpg)  

Виділяємо об'єкт Left і тягнемо приблизно де він буде розташований під час гри.
Якщо ви зараз спробуєте запустити гру, вікно все ще буде виглядати порожнім.
Це тому, що, хоч ми вже маємо колайдер, він сам по собі ніяк не відображається. Нам потрібен спрайт, тобто зображення.

Зупиняємо гру і до вузла Left додаємо Sprite. В полі пошуку набираємо "Spri" і ось він синеньким значком посміхається нам.

![Image](/images/NodeSprite.jpg)  

В інспекторі нас цікавить поле Texture. Туди ми перетягуємо нашу іконку. Поки не будемо створювати ніяких нових текстур. Нам вистачить і цієї.
Потрібно підігнати розмір текстури до розміру колайдера. Тягаємо кружечки і підганяємо.

{{< video autoplay="true" muted="true" loop="true" src="SpriteResize" >}}

Зараз можемо теж натиснути на замок, щоб ми більше не порушили розташування спрайта.
Якщо гру запустити цього разу, то ми вже побачимо спрайт на лівій стороні вікна.
Вже за крок ми почнемо створювати наш перший код, який управлятиме дощечками.
Але перед тим, потрібно зробити додаткові налаштування. Потрібно визначити, які клавіші відповідатимуть за управління кожної з дощечок. Для цього Годот має окремий інструмент. Перейдемо в `Project` -> `Project Settings`. Це вікно має багато всього що стосується налаштування вашого проекту. Ми ще не раз вернемось до нього під час цього курсу. Але сьогодні нас цікавитиме вкладка Input Map. Тут визначається мапа управління. Як бачите, якісь базові речі вже заповнено. Але ми створимо нові.

Як це працює? В полі Action ми можемо створити якусь дію з визначеною назвою. Наша гра передбачає два гравці, лівий і правий. Кожен з них може рухати свою дощечку вверх або вниз. Отже, нам потрібні 4 дії. Лівий вверх, лівий вниз, і правий вверх, правий вниз.
Створимо їх. В назві такої дії не можна використовувати пробіл, тому пишемо для першої дії "left_up", натискаємо додати. За нею таким же чином створюємо "left_down", "right_up" та "right_down". Всі назви з знаком нижнє підкреслення замість пробілу.

{{< video autoplay="true" muted="true" loop="true" src="NewActions" >}}

Всі наші дії розташувались внизу списку. Тепер нам потрібно визначити, які саме клавіші відповідатимуть за них. Натискаємо плюсик навпроти кожної і обираємо Key. для лівого можна обрати клавіші W та S, а для правого стрілки вгору та вниз відповідно. Коли завершили налаштування, закриваємо віконце.

{{< video autoplay="true" muted="true" loop="true" src="EditActions" >}}

Все готово, для того, щоб почати програмувати.

Виділяємо нашу ліву дощечку. А тепер зверніть увагу в самий низ інспектора на правій панелі. У нас є поле Script і воно зазначено як Empty, тобто, порожнє. Натискаємо на це поле і обираємо "New Script". В віконці, що вискочило перед нами, маємо можливість дати назву нашому сценарію. Витираємо слово left та пишемо paddle. Так англійською називають ракетки для настільного тенісу.
Одразу відкривається текстовий редактор і ми бачимо тут якісь закоментовані рядки. Це невеличкі підказки для нас.

{{< video autoplay="true" muted="true" loop="true" src="NewScript" >}}

Трошки розкажу про мову, яка використовується в Godot. Попри те, що цей рушійчик дозволяє писати на різних мовах, які включають С++, C#, чи навіть пітон, основною мовою якою рекомендовано користуватись, це власна мова GDScript.

Так от, мова яку ми сьогодні будемо використовувати, являється мовою інтерпретатора. Тобто, вона залишається і розповсюджується в текстовій формі. При цьому сам рушійчик інтерпретує її на льоту. Це має свої недоліки, але і серйозні переваги. Також ця мова є динамічно типізованою і бере свої основи з мови Pyton. Хоч і має деякі серйозні відмінності. Це означає, що вам не потрібно вказувати, до якого типу належить ваша змінна. Як ви можете бачити з прикладу, достатньо написати `var a = 2`. Де `var` це зарезервоване слово, яке просто означає, що мова іде про змінну. Так само можна оголосити константу написавши `const`. Із контексту Годот приймає рішення, до якого типу належить змінна.
В першому випадку змінна `a` являється цілочисельною. Якщо б ми написали
`var a = 2.0` тоді вона б відносилась до чисел з плаваючою точкою.
Друга змінна текстова. Одна суттєва відмінність від все того ж **Python**, це те, що якщо змінну вже було ініціалізовано в якийсь тип, ви більше не можете її перепризначити в інший. В змінну `a`, яка у нас буде цілочисельною я не можу в наступному рядку записати текст.

Але вернемось до першого рядка. Тут написано `expend Area2D`. Це означає, що ми наслідуємо клас Area2D з усіма його особливостями і відповідно, наш клас `paddle` буде їх розширяти.

Далі ми бачимо приклад оголошення функції. 

![Image](/images/ReadyFunc.jpg)  

Ця функція дуже особлива. Вона виконується відразу, як тільки об'єкт додано в сцену. В нашому випадку, він уже в сцені, тому функція виконається на першому кадрі гри. Це дозволяє нам зробити всі попередні налаштування, перш ніж об'єкт повною мірою стане активним. Тут буде ініціалізація всіляких змінних.


Наступна функція, яка поки закоментована, теж особлива. 

![Image](/images/ProcFunc.jpg)  

Вона виконується кожен раз, коли перемальовується картинка на екрані. Існує ще одна подібна функція, `_physics_process`. Подібно до `process`, яка, нагадую, виконується кожен раз коли перемальовується екран, фізичний процес виконується кожен раз, коли відбувається перерахунок фізичного кадру.
Якщо частота перемалювання кадрів на екран може змінюватись від того, наскільки швидко конкретний пристрій може опрацьовувати гру, фізичний кадр має досить строгу частоту яка визначається в налаштуваннях гри. За звичай, частота фізичних кадрів виставлена на рівні 60 кадрів на секунду. 

Отже, є два процеси, які повторюються з певною періодичністю, один з них фізичний, зі строгою періодичністю, другий графічний, періодичність якого не настільки критична.

В нашій грі не настільки важливо прив'язуватись до строгого фізичного такту. Тому, ми скористаємось функцією `_process`.
Забираємо символ решітки на початку рядка, щоб розкоментувати функцію. Але відразу бачимо повідомлення про помилку. Діло в тім, що нам не дозволено мати порожню функцію. Вона повинна мати хоча б одну операцію. Для таких випадків існує операції `pass`. Це порожня операція. Така собі пустушка. Розкоментуйте і її.
Далі маю звернути вашу увагу, що мова Gdscript наслідувала відступи, для визначення блоків, як і пітон. Тут немає ніяких фігурних дужок. Все що в тілі функції має мати один відступ від краю.

Пора вже щось порухати. Для цього нам потрібно дізнатись, яку з клавіш все таки натиснув гравець.

Створимо змінну `input` з маленької літери в тілі функції `process`.
Далі пишемо `var input = Input` цього разу з великої. `Input` з великої літери, це такий особливий об'єкт який віртуально існує в одному екземплярі і опрацьовує все що стосується пристроїв вводу. У нього, у цього об'єкту, ми можемо запитати, що у нас сталось такого цікавого, з останнього разу, як ми до нього звертались. Нас буде цікавити така штука, як сила натиску дії. Вона повертає значення 0, якщо зовсім не натиснуто клавішу, чи 1, якщо її натиснуто. У випадку роботи з клавіатурою, це все що ми можемо отримати. Для деяких, так званих аналогових клавіш, які бувають на джойстиках, ми можемо отримати будь-яке значення між 0 і один. Тобто, якщо напів натиснуто, то 0.5 і тому подібне.
Маючи значення сили натиску для клавіш вверх і вниз ми можемо визначити напрямок руху. Отже, ми маємо отримати щось таке:

{{< highlight GDScript >}}
var input = Input.get_action_strength("left_down") - Input.get_action_strength("left_up")
{{< / highlight >}}

Маючи це значення в змінній, ми вже можемо рухати дощечку.
в наступному рядку додаємо:

{{< highlight GDScript >}}
position.y = position.y + input
{{< / highlight >}}
Спробуйте запустити гру і понатискати клавіші для лівого гравця.

Отже, дощечка рухається занадто швидко. Також, вона не зупиняється а виходить за межі екрану. Але є ще й третя проблема. Як я вже казав, частота перемалювання екрану ніяк не зафіксована. Тому, якщо гра буде виконуватись на швидкому пристрої, дощечка рухатиметься ще швидше. А якщо на повільнішому, то відповідно повільніше. А це означає, що гравці по суті гратимуть різну гру.
Щоб цього уникнути існує такий параметр як `delta`. Він передається функції `process` як вхідний параметр.
`delta` \- це всього лише значення кількості часу, який сплинув з моменту, коли було намальовано попередній кадр. Час цей зазначений в секундах.
Чим довша затримка, тим більше це значення буде. 10 мілісекунд, 100...

Це значення виступає хорошим інструментом, щоб компенсувати нашу проблему. Просто домножуємо наш `input` на величину `delta`.

Але якщо ви спробуєте гру зараз, то помітите, що рух дощечки дуууже сповільнився. Це тому, що значення `delta` дуже маленьке. Щоб прискорити рух, домножуємо все це ще на якесь число. Наприклад **200**. 


От ми і вирішили проблему швидкості руху. Залишилось питання обмеження. Щоб дощечка не виходила за межі екрану.
Для цього скористаємось функцією `clamp`. Вона якраз для цього і існує, щоб обмежити якесь значення.
Ми це все можемо записати в один рядок. Але просто для наочності обмеження винесемо в новий.
Пишемо:

{{< highlight GDScript >}}
position.y = clamp(position.y, 0, 500)
{{< / highlight >}}

Координати екрану рахуються від верхнього правого кутка. Значення `x` іде зліва на право. А значення `y` іде зверху вниз.
Тож ми обмежили зверху починаючи з 0, до низу, просто намагались вгадати і встановили 500. Зараз ми виправимо ці значення.
Як бачимо, 0, це трохи замала величина. Наша дощечка заходить за екран якраз до середини. Але щоб не гадати, поглянемо на те, що ми вказали в розмірі колайдера. Ми вказали 50, це означає, що він відхиляється від центру на 50 в кожен бік. Тому, замість 0 пишемо 50.

А щодо нижнього значення, нам треба знати розмір екрану. Для цього існує спеціальна функція

{{< highlight GDScript >}}
get_viewport_rect()
{{< / highlight >}}
Вона повертає різноманітні параметри прямокутника, в який ми малюємо. Нас цікавить значення `size.y`. Тобто, розмір вікна по вертикалі.
Не забуваємо також відняти все ті ж 50 пікселів, щоб не було тієї ж проблеми, як зверху. Ось що ми маємо отримати: 

{{< highlight GDScript >}}
func _process(delta):
	var input = Input.get_action_strength("left_down") - Input.get_action_strength("left_up")
	position.y = position.y + input * 200 * delta
	position.y = clamp(position.y, 50, get_viewport_rect().size.y - 50)
{{< / highlight >}}

Зараз можемо перевірити, чи все працює, як і було в наших замислах. Ще раз розгляньте код, та перечитайте кожен рядок. Чи є щось, що є для вас не зрозумілим?

Далі ми продовжимо зі створення ракетки для правого гравця...
