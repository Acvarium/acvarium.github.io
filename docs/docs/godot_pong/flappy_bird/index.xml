<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Flappy Bird on 3D Vitalii Shmorhun</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/</link>
        <description>Recent content in Flappy Bird on 3D Vitalii Shmorhun</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>uk-ua</language><atom:link href="http://localhost:1313/docs/godot_pong/flappy_bird/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>1. Налаштування проекту</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/game_setup/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/game_setup/</guid>
        <description>&lt;h1 id=&#34;налаштування-проекту&#34;&gt;Налаштування проекту
&lt;/h1&gt;&lt;p&gt;Почнемо цього разу з заготовленого проекту, який ви можете завантажити тут:&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/download/flappy_start.zip&#34; &gt;flappy_start.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Розпакуйте архів з проектом де вам зручно, проскануйте менеджером проектів, та відкрийте.
Цей пакунок дасть вам усі необхідні зображення, які ми будемо використовувати.&lt;/p&gt;
&lt;p&gt;Далі наша гра потребує певних налаштувань.
Для цього, переходимо до меню &lt;code&gt;Project&lt;/code&gt; -&amp;gt; &lt;code&gt;Project Settings&lt;/code&gt;. Там шукаємо розділ &lt;code&gt;Window&lt;/code&gt;. Змінюємо розмір екрану на 480 на 854.&lt;/p&gt;
&lt;p&gt;Прокрутимо трохи нижче, та встановимо орієнтація в &lt;code&gt;Portrait&lt;/code&gt; замість ландшафтної, щоб наша гра правильно відображалась на мобільних пристроях, оскільки вона передбачає вертикальну орієнтацію. Далі визначаємо режим розтягування як 2d, та співвідношення сторін, &lt;code&gt;Aspect&lt;/code&gt; в &lt;code&gt;Keep&lt;/code&gt;. Це гарантуватиме, що екран гри виглядатиме ідентично на всіх пристроях, не залежно від їх співвідношення сторін.&lt;/p&gt;
&lt;p&gt;Далі переходимо в розділ &lt;code&gt;Input Devices&lt;/code&gt; секцію &lt;code&gt;Pointing&lt;/code&gt;. Тут відмічаємо опцію &lt;code&gt;Emulate Touch From Mouse&lt;/code&gt;. Це означає, що наша гра отримуватиме сигнали від натискання і протягування мишки, такі, як би отримувала, якщо б це був сенсорний дисплей і натискання його дотиком одного пальця.&lt;/p&gt;
&lt;p&gt;Можемо закрити це вікно налаштувань. Зараз якщо ми віддалимось трохи, то побачимо тонкі лінії, що окреслюють межі нашого вікна. Як ви можете помітити, вікно виходить вертикальним. Саме так, як ми хотіли.&lt;/p&gt;
&lt;p&gt;Далі створимо нашу головну сцену. Для цього на панелі сцени оберемо 2D Scene та перейменуємо кореневий вузол в Main. Натискаємо комбінацію Ctrl+S та зберігаємо сцену в корені проекту.&lt;/p&gt;
&lt;p&gt;На завершення загальних налаштувань, додамо до сцени вузол &lt;code&gt;Sprite&lt;/code&gt;, який буде нашим небом в грі. Перейменуйте його в Sky, далі знайдіть в ресурсах гри відповідну текстуру з назвою Sky і затягніть її в інспектор в поле Texture. За замовчуванням зображення центрується. Нам це не потрібно. Тому в розділі Offset знайдіть галочку Centered та зніміть її. Розтягнемо наше зображення так, щоб воно вкривало все вікно гри.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>2. Сцена гравця</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/player_scene/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/player_scene/</guid>
        <description>&lt;h1 id=&#34;сцена-гравця&#34;&gt;Сцена гравця
&lt;/h1&gt;&lt;p&gt;Отже, ми приступаємо до створення персонажу, котрим керуватиме гравець.&lt;/p&gt;
&lt;p&gt;Ми його виділимо в окрему сцену. Для цього, натискаємо меню &lt;code&gt;Scene&lt;/code&gt; -&amp;gt; &lt;code&gt;New Scene&lt;/code&gt;. Кореневим вузлом тут буде &lt;code&gt;Rigid Bidy 2D&lt;/code&gt;. Це фізичний об&amp;rsquo;єкт. Ми уже знайомі з одним з типів фізичних об&amp;rsquo;єктів. Коли ми розробляли гру &lt;code&gt;Pong&lt;/code&gt; то використовували вузли &lt;code&gt;Area2D&lt;/code&gt;, які являються найпростішою формою фізичного об&amp;rsquo;єкта. Все що вони мають, це певну форму, і реагують на перетин цієї форми іншими фізичними об&amp;rsquo;єктами.&lt;/p&gt;
&lt;p&gt;Сьогодні ж ми будемо працювати з другим типом, що називається &lt;code&gt;Rigid Body 2D&lt;/code&gt;. Це саме те, що можна уявити, якщо думати про фізичний об&amp;rsquo;єкт. Він має форму, на нього діє гравітація, а отже, він падає. Він характеризується тертям, згасанням руху, для дуже спрощеної підміни тертя повітря, його можна налаштувати відбиватись від поверхні і тому подібне. Одна важлива річ, яку треба тримати в голові, коли ми маємо справу з подібним об&amp;rsquo;єктом, це те, що його не можна напряму переміщати з коду, як ми робили з дощечками для &lt;code&gt;Pong&lt;/code&gt;. Тобто, вам не дозволено змінювати його координати. Єдине, що вам дозволяється у випадку з &lt;code&gt;Rigid Body&lt;/code&gt;, це надати об&amp;rsquo;єкту імпульс в якомусь напрямку, чи якимось іншим чином прикладати силу.&lt;/p&gt;
&lt;p&gt;Сьогодні ми також використаємо вузол під назвою &lt;code&gt;Static Body 2D&lt;/code&gt;. Як випливає з імені, це статичний об&amp;rsquo;єкт, вся робота якого, бути на одному місці і мати певну форму. Подібні об&amp;rsquo;єкти формують статичні перешкоди, як то землю чи стіни рівня. Але це саме статичні перешкоди. Хоч ви і можете переміщати з коду чи анімацією подібні об&amp;rsquo;єкти, цього потрібно уникати. Такі переміщення можуть викликати неочікувану поведінку, тому що фізична система є сильно оптимізованою, і не передбачає рух таких об&amp;rsquo;єктів&lt;/p&gt;
&lt;p&gt;Також є ще один важливий тип фізичних об&amp;rsquo;єктів, з яким ми познайомимось пізніше. Він називається &lt;code&gt;Kinematic Body&lt;/code&gt;. Вузли такого типу є під повним контролем програміста. Ви визначаєте в коді все, що стосується його поведінки і в цьому випадку можете рухати його як заманеться. Але додатково вам надається доступ до функцій, що опрацьовують зіткнення з поверхнями різним чином. Але про це ми поговоримо пізніше, в іншому проекті.&lt;/p&gt;
&lt;p&gt;Отже, у нас є нова сцена поки без жодного вузла. В короткому списку меню немає необхідного. Натискаємо Other Node та шукаємо &lt;code&gt;RigidBidy2D&lt;/code&gt;. Перейменуємо його в &lt;code&gt;Player&lt;/code&gt;. Знак оклику нам нагадує, що потрібно додати колайдер. Додаємо новий вузол &lt;code&gt;CollisionShape2D&lt;/code&gt;. Як форму в інспекторі справа обираємо коло. Радіус ми зараз поправимо, коли додамо і визначимось з розміром спрайта.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyNewPlayerScene&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyNewPlayerScene&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;До вузла &lt;code&gt;Player&lt;/code&gt; додаємо ще один. Цього разу &lt;code&gt;Sprite&lt;/code&gt;. Серед спрайтів шукаємо той, що має назву &lt;code&gt;bird&lt;/code&gt; та затягуємо в поле &lt;code&gt;Texture&lt;/code&gt; в інспекторі. Як бачите, тут відразу 2 кадри які ми використаємо для анімації. Але поки, розгортаємо розділ &lt;code&gt;Animation&lt;/code&gt; в інспекторі та змінюємо значення &lt;code&gt;Hframes&lt;/code&gt;, тобто кількість кадрів по горизонталі, на 2. Наша птаха трохи завелика. Вона займає велику частину ігрового екрану. Переходимо в розділ &lt;code&gt;Transform&lt;/code&gt; та змінюємо обидва значення &lt;code&gt;scale&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; та &lt;code&gt;y&lt;/code&gt; на величину 0.25. Тепер ми можемо повернутись до розміру колайдера. Поміняйте їх місцями в ієрархії сцени, щоб зручніше було підганяти розмір колайдера за коліщатко справа. Як бачимо, спрайт пташки ще трохи зміщений вправо. Виділяємо спрайт і стрілками на клавіатурі рухаємо трохи вліво. Те що частина зображення птаха виходить за межі колайдера, це не суттєво в подібній грі. Та і гравцю треба давати трошки простору на помилку.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyPlayerSprite&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyPlayerSprite&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Збережемо нашу сцену. Для цього створимо новий каталог під назвою &lt;code&gt;Characters&lt;/code&gt;. Це дозволить вам в майбутньому розширити гру, додавши кілька персонажів на вибір для гравця. Зберігаємо під тією ж назвою, &lt;code&gt;Player&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Далі ми будемо робити анімацію персонажа. Перша буде відтворюватись доти, поки гравець не розпочне гру. Птах буде злегка коливатись на місці. Друга ж анімація буде відтворюватись вже під час гри. Птах буде рухати крилами.&lt;/p&gt;
&lt;p&gt;Отже, для того, щоб мати анімацію в грі, нам потрібен вузол &lt;code&gt;AnimationPlayer&lt;/code&gt;. Додамо його як дочірній до вузла Player. Коли його виділено, ми бачимо новий тип вікна, внизу. Це інструмент для створення і редагування анімації. Натискаємо &lt;code&gt;Animation&lt;/code&gt; -&amp;gt; &lt;code&gt;New&lt;/code&gt; та називаємо першу анімацію &lt;code&gt;idle&lt;/code&gt;, що означає бездіяння. Вона буде мати тривалість 1 секунду, що можна визначити справа. Вона має бути циклічною, вмикаємо кнопочку правіше. Також вона має відтворюватись автоматично відразу як розпочато гру. Для цього натискаємо кнопочку з літерою &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyNewAnimationPlayer&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyNewAnimationPlayer&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Створимо перший кадр. Бігунок часу має бути в нулі. Виділяємо спрайт. Стрілками клавіатури рухаємо його трохи вниз. Тепер в полі &lt;code&gt;Transform&lt;/code&gt; натискаємо ключик навпроти параметру &lt;code&gt;Position&lt;/code&gt;. Він запитає, чи створити нову доріжку анімації і чи створити доріжку в анімації Reset. Натискаємо Create. Зверніть увагу, що ключик навпроти параметра не завжди присутній. Він з&amp;rsquo;являється після того, як ми виділили &lt;code&gt;AnimationPlayer&lt;/code&gt; з анімацією на редагування.&lt;/p&gt;
&lt;p&gt;Наступний кадр буде на позиції 0.5. Пересуваємо бігунок. Знову переконуємось, що спрайт виділено та стрілкою перемістимо його вгору трохи вище позиції спокою. Створюємо новий ключ анімації, натиснувши на ключик навпроти &lt;code&gt;Position&lt;/code&gt;. У нас є перша анімація. Щоб відтворити її, в вікні анімації натискаємо клавішу відтворення.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyIdleAnimation&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyIdleAnimation&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Приступаємо до другої анімації. Ця буде відтворюватись циклічно впродовж всієї гри. Вона буде відображати рух крил пташки. Для цього, як ви пам&amp;rsquo;ятаєте, спрайт має два кадри. Тож, ми будемо їх перемикати. Знову створюємо нову анімацію, натискаючи &lt;code&gt;Animation&lt;/code&gt; -&amp;gt; &lt;code&gt;New&lt;/code&gt; та називаємо її &lt;code&gt;flap&lt;/code&gt;. Справа вмикаємо циклічність та поряд міняємо довжину на 0.2 секунди. Переконуємось, що бігунок часу на відмітці 0. Виділяємо спрайт та в розділі &lt;code&gt;Animation&lt;/code&gt; шукаємо значення &lt;code&gt;Frame&lt;/code&gt;. Виставляємо ключик та створюємо нову доріжку. Пересуваємо бігунок часу на 0.1. Змінюємо значення &lt;code&gt;Frame&lt;/code&gt; для спрайта на 1 та знову додаємо ключ. Зараз ми вже можемо відтворити анімацію. Але це ще не кінець роботи в цьому вікні.
Кожна з наших анімацій змінює свій тип величин. Перша впливає на позицію, друга на кадр. Відповідно може бути випадок, коли позицію зміщено першою анімацією і ми перейшли в другу. Але друга ніяк не виправила ситуацію, тож наш птах залишиться зміщеним відносно колайдера, що, з точки зору гравця, ускладнює ігровий процес. Гравець вже не знатиме коректної позиції і зіткнення для нього будуть відбуватись дивним чином.
Це потрібно поправити. Для цього достатньо для початку в анімації &lt;code&gt;flap&lt;/code&gt; виставити спрайт в правильну позицію і створити новий кадр для значення &lt;code&gt;position&lt;/code&gt; на відмітці часу 0.
Таке ж саме зробимо для значення &lt;code&gt;frame&lt;/code&gt; в анімації &lt;code&gt;idle&lt;/code&gt;. Повертаємо в 0, та створюємо кадр.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyFlapAnimation&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyFlapAnimation&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Зараз можемо зберегти зміни, що ми зробили в сцені та рухаємось далі.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>3. Сценарій гравця</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/player_script/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/player_script/</guid>
        <description>&lt;h1 id=&#34;сценарій-гравця&#34;&gt;Сценарій гравця
&lt;/h1&gt;&lt;p&gt;В цій секції роботи ми підготуємо код для гравця.
Почнемо з того, що додамо вузол гравця в основну сцену. Для цього переходимо в сцену &lt;code&gt;Main&lt;/code&gt;, натискаємо правою на &lt;code&gt;Main&lt;/code&gt; та обираємо &lt;code&gt;Instance Child Scene&lt;/code&gt;.
Птах з&amp;rsquo;явився в центрі координат, що знаходиться в верхньому лівому кутку екрану. Перемістимо його в правильну позицію. Для цього виділяємо вузол &lt;code&gt;Player&lt;/code&gt; та в інспекторі шукаємо розділ &lt;code&gt;Transform&lt;/code&gt;. Задаємо позицію в x 115 та y 427.&lt;/p&gt;
&lt;p&gt;Спробуйте зараз запустити гру. Птах повинен повільно падати. Це на нього діє гравітація. Зверніть увагу в інспекторі серед параметрів для вузла &lt;code&gt;Player&lt;/code&gt; є один, що має назву &lt;code&gt;Gravity Scale&lt;/code&gt;. На даний момент він рівний 1. Ця величина визначає, як слідує з назви, наскільки сильно впливає гравітація на об&amp;rsquo;єкт.&lt;/p&gt;
&lt;p&gt;Спробуйте виставити значення 0 та ще раз запустити гру.&lt;/p&gt;
&lt;p&gt;Цього разу птах повинен тільки злегка коливатись на місці. Саме так. як ми його анімували. Це буде режим очікування першого натиску від гравця, після чого гра розпочнеться.&lt;/p&gt;
&lt;p&gt;Повернемось до сцени гравця.
Змінимо тут значення &lt;code&gt;Gravity Scale&lt;/code&gt; на нуль. За хвилину ми додамо код, який буде впливати на це значення.
Створимо новий сценарій для вузла &lt;code&gt;Player&lt;/code&gt;. Для зручності можемо вибрати порожній шаблон.
Перш-ніж взятись за код, перейдемо до &lt;code&gt;Project Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Input Map&lt;/code&gt; та створимо нову дія під назвою &lt;code&gt;flap&lt;/code&gt;. Ключем для цієї дії буде натискання лівої клавіші мишки. Пізніше нам буде потрібно в коді розширити опитування ще й на дотик екрану, якщо ми хочемо, щоб гра працювала на мобільних пристроях.&lt;/p&gt;
&lt;p&gt;Повертаємось до коду гравця.
З минулого проекту ви могли запам&amp;rsquo;ятати, що існує 2 процеси, які викликаються циклічно для кожного кадру, що промальовується та для кожного фізичного кадру. Ми маємо справу цього разу з &lt;code&gt;Rigig Body&lt;/code&gt;, який є динамічним фізичним об&amp;rsquo;єктом. Нам важливо, щоб вплив на нього був прив&amp;rsquo;язаний саме до фізичного циклу. Тому створюємо функцію &lt;code&gt;__physics_process(delta):&lt;/code&gt; а в тілі цієї функції опитуємо у об&amp;rsquo;єкта-сінглтона &lt;code&gt;Input&lt;/code&gt;, чи не надходила подія &lt;code&gt;flap&lt;/code&gt;.
В результаті ми отримаємо код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Створимо нову функцію, яка буде виконуватись на старті гри, як тільки гравець натиснув перший раз. Назвемо цю функцію просто &lt;code&gt;start()&lt;/code&gt;.
Також нам потрібна змінна, яка буде слідкувати, чи гру уже розпочато. Тож, оголосимо глобальну змінну:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Всередині функції &lt;code&gt;start()&lt;/code&gt; перевіряємо, якщо змінна рівна &lt;code&gt;true&lt;/code&gt;, виходимо з функції без жодної дії:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Якщо ні, встановлюємо&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Так ми переконуємось, що все, що буде далі в цій функції буде виконуватись тільки раз після старту.
Далі змінюємо значення &lt;code&gt;gravity_scale&lt;/code&gt; на величину 8, оскільки ви могли звернути увагу, що значення 1 дає занадто слабку гравітацію. Цю величину можна балансувати в подальшому.
Наступне, що ми маємо зробити, це перемкнути анімацію на ту, де птах махає крилами. Для цього ми можемо звернутись до вузла &lt;code&gt;AnimationPlayer&lt;/code&gt;, який є в ієрархії гравця. &lt;code&gt;Godot&lt;/code&gt; має зручний спосіб звернення до вузлів. Достатньо в коді поставити знак долара, а далі шлях до вузла в ієрархії. Так ми можемо викликати метод &lt;code&gt;play()&lt;/code&gt; для плеєра. Тож, рядок виглядатиме так:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Ще один важливий момент, це те, що фізичні об&amp;rsquo;єкти мають властивість спати. Це оптимізація. Якщо об&amp;rsquo;єкт достатньо часу не рухається, фізична система приймає, що він досяг стабільної позиції. Тоді, щоб не затрачати на перерахунок руху цього об&amp;rsquo;єкту, фізична система &amp;ldquo;кладе його спати&amp;rdquo;. У випадку, якщо поряд з&amp;rsquo;явиться якась сила, здатна зрушити об&amp;rsquo;єкт, його знову розбудять.
Але ми поки не застосували ніяких сил і не впливали ніяк на рух гравця. Тож якщо ми зараз запустимо гру, навіть після натискання і зміни масштабу гравітації, птах залишатиметься на місці. Тимчасово ми можемо додати строку, яка його розбудить. В подальшому вона може бути не потрібна, оскільки ми будемо робити додаткові маніпуляції. Але зараз, просто для тестування, додамо в функцію &lt;code&gt;start()&lt;/code&gt; ще один рядок:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sleeping&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Запускаємо гру та пробуємо натиснути де-небудь в межах вікна. Якщо все зроблено правильно, ми маємо побачити дві речі:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Птах починає падати&lt;/li&gt;
&lt;li&gt;Птах змінює анімацію&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Чого далі ми чекаємо від гри? Що повинно відбуватись, коли ми натискаємо на екран? Ми хочемо, щоб гравець рухався вгору, а також, щоб він повертався, схоже на те, як це виглядає в оригінальній грі.
Ці процеси буде описано в новій функції. Ми назвемо її &lt;code&gt;flap()&lt;/code&gt;
Ця функція повинна викликатись кожен раз, коли відбулась дія &lt;code&gt;flap&lt;/code&gt;, тож допишімо виклик цієї функції в &lt;code&gt;_physics_process&lt;/code&gt; якщо щойно натиснуто дію &lt;code&gt;flap&lt;/code&gt;.
Визначимо нову глобальну змінну &lt;code&gt;FLAP_FORCE&lt;/code&gt;. Як свідчить з назви, вона зберігатиме силу поштовху вгору.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Величина від&amp;rsquo;ємна, бо ми рухаємось вгору.
Об&amp;rsquo;єкти класу &lt;code&gt;Rigid Body&lt;/code&gt; мають таку величину, що називається &lt;code&gt;linear_velocity&lt;/code&gt;. Це вектор. В цьому випадку двовимірний вектор, оскільки ми працюємо з 2-вимірним світом. Цей вектор виражає швидкість і напрям руху. Ми можемо напряму вносити туди значення, що відразу впливатиме на рух об&amp;rsquo;єкту.
Ми будемо вносити зміни тільки в вертикальну складову цього вектору, оскільки замість того, щоб рухати пташку до перешкод, ми будемо рухати перешкоди до пташки.
Отже, в функції &lt;code&gt;flap()&lt;/code&gt; вказуємо:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;flap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;linear_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Сама ж функція &lt;code&gt;flap()&lt;/code&gt; викликається у нас так само, як і &lt;code&gt;start()&lt;/code&gt; в &lt;code&gt;_physics_process(delta)&lt;/code&gt;, якщо отримана подія &lt;code&gt;flap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Тож, загалом на цей момент код повинен виглядати так:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RigidBody2D&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;flap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;gravity_scale&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;8.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;sleeping&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;flap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;linear_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Спробуємо гру. Ви повинні бачити, що, якщо натискати на екран, птах починає махати крилами, на нього починає діяти гравітація і при кожному натисненні він трішки підлітає вгору.&lt;/p&gt;
&lt;p&gt;Наступне наше завдання, це повертати птаха. Коли він взлітає, то повинен дивитись вгору. А коли падає, то вниз.
Ми досягнемо цього користуючись параметром &lt;code&gt;angular_velocity&lt;/code&gt;, тобто швидкість і напрям обертання.
Щоб падіння нам не заважало, закоментуємо стрічку, де ми вмикаємо гравітацію. Для цього досить поставити знак решітки на початку рядка. Для цього існує комбінація клавіш &lt;code&gt;Ctrl&lt;/code&gt;+ &lt;code&gt;K&lt;/code&gt;. Також закоментуємо рядок, який надає поштовх вгору, тобто змінює значення &lt;code&gt;linear_velocity.y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В наступному рядку в функції &lt;code&gt;flap()&lt;/code&gt; просто для тесту, що буде відбуватись, дописуємо:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;8.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Зараз, якщо ви натиснете ліву клавішу мишки, ви побачите що птах обертається за годинниковою стрілкою. Отже, додатні значення, це за годинниковою стрілкою.
В цьому випадку нам потрібно протилежний напрям. Тому поміняємо значення на &lt;code&gt;-8.0&lt;/code&gt;.
Також ми не хочемо, щоб гравець продовжував крутитись. Тож, давайте встановимо обмеження на те, наскільки гравець може крутитись.
Вгорі визначаємо константу&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;30.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Далі в тілі функції &lt;code&gt;_physics_process(delta)&lt;/code&gt; після того, як ми викликаємо &lt;code&gt;flap()&lt;/code&gt; і поза перевіркою події &lt;code&gt;flap&lt;/code&gt;, додаємо ще одну перевірку, чи кут не менший за нашу константу.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Тут ми занулили швидкість обертання та визначили, щоб кут був рівний максимальному.
Наступне, що ми маємо зробити, щоб птах, коли падатиме вниз, обертався і дивився вниз.
Для цього ми можемо слідкувати за вектором &lt;code&gt;linear_velocity&lt;/code&gt;. Якщо величина &lt;code&gt;linear_velocity.y&lt;/code&gt; більша за 0, це означає, що ми падаємо.
Отже:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linear_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;90&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Тут ми перевірили, чи гравець падає. Далі, якщо кут менший за 90, то ми визначаємо швидкість обертання як 3.0, в іншому випадку воно має бути рівне 0.&lt;/p&gt;
&lt;p&gt;Щоб це перевірити, не забуваємо розкоментувати два рядки, де ми вмикаємо гравітацію і надаємо поштовх.&lt;/p&gt;
&lt;p&gt;По завершенню цієї роботи, код гравця повинен виглядати таким чином:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RigidBody2D&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;30.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;flap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ROTATION_DEGREES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;linear_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_degrees&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;90&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;3.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;started&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;gravity_scale&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;8.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;sleeping&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;flap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;linear_velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FLAP_FORCE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;angular_velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;8.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>4. Анімація землі</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/animated_ground/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/animated_ground/</guid>
        <description>&lt;h1 id=&#34;анімація-землі&#34;&gt;Анімація землі
&lt;/h1&gt;&lt;p&gt;Анімацію руху землі можна зробити різними способами. Ми будемо реалізовувати ефект паралаксу. Тобто, предмети які ближче до нас будуть рухатись швидше, а ті, які далі, повільніше. Це дозволяє досягнути ефект псевдо-глибини. &lt;code&gt;Godot&lt;/code&gt; має готовий спеціальний набір вузлів, що допомагає якісно робити цей ефект. Але цей підхід передбачає, що камера буде рухатись. А у нашій грі, камера стоїть на місці, так само як гравець, а рухається ввесь навколишній світ, включаючи перешкоди. Тож нам цей підхід не підійде. Можна це реалізувати з коду. Але ми підемо шляхом анімації.&lt;/p&gt;
&lt;p&gt;Почнемо з неба. Його анімувати не потрібно. Воно просто заповнить собою фон.
Тож, повертаємось в сцену &lt;code&gt;Main&lt;/code&gt;. Переходимо в режим &lt;code&gt;2D&lt;/code&gt;, щоб ми могли бачити, що робимо.
Далі, до вузла &lt;code&gt;Main&lt;/code&gt; додаємо дочірній &lt;code&gt;Sprite&lt;/code&gt;. Серед зображень в каталозі &lt;code&gt;sprites&lt;/code&gt; знаходимо той, що має назву &lt;code&gt;sky&lt;/code&gt; та перетягуємо в поле &lt;code&gt;Texture&lt;/code&gt; в інспекторі. Зображення буде відцентровано, чого нам не потрібно. Тож в розділі &lt;code&gt;Offset&lt;/code&gt; знімаємо галочку &lt;code&gt;Centered&lt;/code&gt;. Далі просто розтягуємо зображення, щоб воно вкривало все вікно.
Прослідкуйте, щоб небо не затуляло собою пташку. Якщо потрібно, перемістіть його вгору в ієрархії сцени.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappySky&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappySky&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Далі приступимо до землі. Землю буде представляти вузол &lt;code&gt;StaticBody2D&lt;/code&gt;, оскільки нам треба буде враховувати падіння пташки. Знову для &lt;code&gt;Main&lt;/code&gt; створюємо дочірній вузол типу &lt;code&gt;StaticBody2D&lt;/code&gt;. Називаємо його &lt;code&gt;Ground&lt;/code&gt;. Цьому об&amp;rsquo;єкту потрібен колайдер. Тобто об&amp;rsquo;єкт, котрий визначатиме форму. Але ми поки не знаємо, якою вона повинна бути.
Поглянемо на спрайт, який буде використано для землі.&lt;/p&gt;
&lt;p&gt;Зображення під назвою &lt;code&gt;floor.png&lt;/code&gt; - це квадрат розміром 128 на 128 пікселів.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/floor.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Godot Window&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Одного цього зображення не достатньо, щоб вкрити нижню частину екрану по ширині. Та і розтягувати його ми не будемо. Нам потрібно його розмножити. І тут, знову ж таки, є кілька способів. Ми скористаємось плитковою системою &lt;code&gt;Godot&lt;/code&gt;. Це доволі потужний інструмент, який ми значно більш детально розглянемо в одному з наступний проектів. Зараз просто додаємо до вузла &lt;code&gt;Ground&lt;/code&gt; новий дочірній класу &lt;code&gt;TileMap&lt;/code&gt;. Для роботи цей вузол потребує щось типу бібліотеки плиточок, якої у нас поки немає. Цю саму бібліотеку, чи набір можна, як завжди, створити кількома способами. Ми скористаємось вбудованим редактором. Тож, в інспекторі для цього нового вузла шукаємо параметр &lt;code&gt;Tile Set&lt;/code&gt;. Там розгортаємо та натискаємо &lt;code&gt;New TileSet&lt;/code&gt;. Далі ще раз на нього натискаємо, і на нижній панелі повинен відкритись редактор.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyNewTileSet&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyNewTileSet&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;В редакторі в лівому нижньому кутку натискаємо кнопку з плюсиком далі шукаємо наше зображення &lt;code&gt;floor.png&lt;/code&gt;. Ми обрали текстуру, але поки не вказали, яку секцію з цієї текстури будемо використовувати. Нам потрібне все зображення для однієї плиточки. Тож, натискаємо &lt;code&gt;New Single Tile&lt;/code&gt;. Далі, щоб було зручно виділити все зображення, вмикаємо прив&amp;rsquo;язку до сітки та обмальовуємо зображення. В результаті жовтий контур має бути навколо всієї картинки.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappySingle&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappySingle&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Вже можна вийти з редактора. Для цього достатньо виділити будь-який інший вузол в сцені. Відразу повернемось до вузла &lt;code&gt;TileMap&lt;/code&gt; та ще раз глянемо в інспектор.
По перше, зверніть увагу, що лівіше від інспектору з&amp;rsquo;явилась панель з тою самою бібліотекою плиточок. У нас там тільки один екземпляр. Маючи обраний елемент з набору, можна правою клавішею розкладати їх по сітці, а лівою витирати. Тільки от сітка у нас якась мілка. В інспекторі розгорніть розділ &lt;code&gt;Cell&lt;/code&gt;. Розмір сітки встановлено як 64 на 64 пікселі. Змініть це на 128 на 128. Зараз, від верхнього лівого кутка вправо намалюйте не менше ніж 6 плиточок. Далі оберіть інструмент переміщення та змістіть всю сітку так, щоб квадратики торкались низу екрану. Затискання клавіші &lt;code&gt;Ctrl&lt;/code&gt; під час переміщення допоможе вам не змістити сітку по горизонталі. В результаті позиція повинна бути приблизно (0, 750)&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyTileDraw&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyTileDraw&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Зараз, маючи зображення на своєму місці, ми можемо додати той колайдер, який поки пропустили. Знову виділяємо вузол &lt;code&gt;Ground&lt;/code&gt; та додаємо до нього &lt;code&gt;CollisionShape2D&lt;/code&gt;. Для нього обираємо форму прямокутника. Далі розтягуємо та переміщуємо, щоб він відповідав зображенню.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyFloorColl&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyFloorColl&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Коли завершили з цим, можна приступити до анімації. Знову до вузла &lt;code&gt;Ground&lt;/code&gt; додаємо новий, цього разу &lt;code&gt;AnimationPlayer&lt;/code&gt;.
Там створюємо нову анімацію під назвою &lt;code&gt;scroll&lt;/code&gt;. Довжина залишається 1 секунда. Анімацію робимо циклічною та вмикаємо автоматичний старт.
Далі при бігунку часу на позиції 0 переходимо до об&amp;rsquo;єкту &lt;code&gt;TileMap&lt;/code&gt; та в розділі &lt;code&gt;Transform&lt;/code&gt; ставимо новий ключ параметру &lt;code&gt;position&lt;/code&gt;.
Бігунок часу пересуваємо в кінець. Задаємо позицію в значення -128 для x. Це змістить плитку вліво рівно на розмір 1 сегменту.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyFloorAnim&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyFloorAnim&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Зберігаємо сцену та запускаємо, подивитись, що у нас получилось.&lt;/p&gt;
&lt;p&gt;А має бути у нас на цей момент таке&amp;hellip; По низу екрану рівномірно пропливають квадратики землі. А також, якщо наш птах зараз впаде, то вже не пролетить крізь, а зупиниться на землі. Ми все ще можемо продовжити грати, навіть після зіткнення. Але це ми вирішимо пізніше.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>5. Труба</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/pipe_scene/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/pipe_scene/</guid>
        <description>&lt;h1 id=&#34;сцена-з-трубою&#34;&gt;Сцена з трубою
&lt;/h1&gt;&lt;p&gt;В цій секції проекту ми лише створимо сцену, яка міститиме труби, як перешкоди для польоту гравця. Ми навіть підемо ще трохи дальше. Виділимо трубу в окрему сцену, а вже з двох таких одна над одною зберемо перешкоду.
Створюємо нову сцену натискаючи в меню &lt;code&gt;Scene&lt;/code&gt; -&amp;gt; &lt;code&gt;New Scene&lt;/code&gt;. Ця сцена буде містити одну трубу. Труба має виявляти зіткнення з птахом, тому для цієї ролі найкраще підходить &lt;code&gt;Area2D&lt;/code&gt;, який ми вже розглядали в минулому проекті. Тож, для кореневого вузла сцени обираємо &lt;code&gt;Other Node&lt;/code&gt;, а вже з повного списку можна вибрати потрібний нам &lt;code&gt;Area2D&lt;/code&gt;.
Назвемо вузол &lt;code&gt;Wall&lt;/code&gt;, так як це можуть бути не обов&amp;rsquo;язково труби і ми можемо мати декілька варіантів оформлення гри. Елемент виконує роль стіни, отже, називатиметься &lt;code&gt;Wall&lt;/code&gt;.
Далі ми додаємо елемент під назвою &lt;code&gt;NinePatchRect&lt;/code&gt;. &lt;code&gt;Nine Patch&lt;/code&gt; це таке зображення, що поділено на 9 прямокутників сіткою 3x3. Цей поділ визначає, яка секція зображення і в якому напрямку може розтягуватись. Щоб краще зрозуміти, як це працює і для чого, розглянемо приклад нижче:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ninepatch.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Тут ви бачите зображення для клавіші чи панелі. Воно має заокруглені кути. Якщо ми хочемо тримати продовгувату кнопку, і просто розтягнемо картинку, то ці кути виглядатимуть зовсім не так, як би нам хотілось. Але якщо розбити на секції, як ми це зробили, а тоді розтягнути тільки середні секції, а кути залишити незмінними, то вийде щось краще. Справа ви можете побачити приклади такого використання в кількох варіаціях.&lt;/p&gt;
&lt;p&gt;Для труби ми скористаємось подібним підходом. Наше зображення досить невелике. І якщо ми розтягнемо його до потрібної висоти, воно виглядатиме огидно.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pipe.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Тож, для початку перейменуємо наш новий вузол класу &lt;code&gt;NinePatchRect&lt;/code&gt; в &lt;code&gt;Pipe&lt;/code&gt;. Далі в інспектор в розділ &lt;code&gt;Texture&lt;/code&gt; затягнемо зображення &lt;code&gt;pipe.png&lt;/code&gt;. Після цього на нижній панелі для нас відкриється редактор, що дозволяє визначити секції зображення. Нам потрібно розбити це зображення тільки на 3 секції по вертикалі. Тягнемо верхню полосу так, щоб вона була трохи нижче темно зеленої тіні від широкої частини труби. Потім нижню лінію зовсім трохи піднімаємо.
У нас має вийти щось таке:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/nine_patch_pipe.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Далі в інспекторі переходимо в розділ &lt;code&gt;Rect&lt;/code&gt;. Перше, що змінюємо, це позицію. Виставляємо значення -40 для x. В секції &lt;code&gt;size&lt;/code&gt; виставляємо x 80, y 1000.
Висота в 1000 пікселів дає нам достатній запас, щоб розмістити перешкоду в будь-яку позицію по вертикалі.&lt;/p&gt;
&lt;p&gt;Ми все ще не додали колайдер, який обов&amp;rsquo;язковий для роботи вузла &lt;code&gt;Area2D&lt;/code&gt;. Тож, до кореневого вузла додаємо новий &lt;code&gt;CollisionShape2D&lt;/code&gt;. Форму обираємо прямокутник та змінюємо розміри щоб він вкривав собою верхню частину труби. Ту, що ширша. Далі таким самим чином створюємо новий вузол &lt;code&gt;CollisionShape2D&lt;/code&gt;, знову обираємо прямокутник і цього разу вкриваємо ним всю нижню частину труби. Колайдери можуть перетинатись. Отже, будь-який фізичний об&amp;rsquo;єкт може мати складні форми, які виражаються кількома колайдерами.&lt;/p&gt;
&lt;p&gt;Зберігаємо сцену.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>6. Сцена перешкоди</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_scene/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_scene/</guid>
        <description>&lt;h1 id=&#34;сцена-перешкоди&#34;&gt;Сцена перешкоди
&lt;/h1&gt;&lt;p&gt;Знову, створюємо нову сцену. Цього разу кореневим вузлом буде звичайний &lt;code&gt;Node2D&lt;/code&gt;. Перейменовуємо в &lt;code&gt;Obstacle&lt;/code&gt;, тобто, перешкода. До цього вузла натискаємо &lt;code&gt;Instance Child Scene&lt;/code&gt; та обираємо файл &lt;code&gt;Wall&lt;/code&gt;, котрий ми щойно зробили. Для цього вузла в інспекторі в секції &lt;code&gt;Transform&lt;/code&gt; позицію по осі y визначаємо як 75.&lt;/p&gt;
&lt;p&gt;Повернемось до вузла &lt;code&gt;Obstacle&lt;/code&gt; та створимо йому новий порожній сценарій. Поки тут нічого не пишемо. Нас поки цікавлять сигнали від &lt;code&gt;Area2D&lt;/code&gt;.
Повертаємось до об&amp;rsquo;єкту &lt;code&gt;Wall&lt;/code&gt;, щоб під&amp;rsquo;єднати сигнал. На правій панелі перемикаємось на вкладку &lt;code&gt;Node&lt;/code&gt;. Там серед сигналів шукаємо &lt;code&gt;body_entered&lt;/code&gt;. Під&amp;rsquo;єднуємо цей сигнал до коду вузла &lt;code&gt;Obstacle&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В цій новоствореній функції ми маємо послідовно визначити, чи цей об&amp;rsquo;єкт і справді гравець. Для цього просто перевіримо, чи його ім&amp;rsquo;я &lt;code&gt;Player&lt;/code&gt;. Далі нам буде потрібно перевірити, чи має цей об&amp;rsquo;єкт метод &lt;code&gt;die()&lt;/code&gt;, та, якщо це так, викликати цей метод.
Отже, отримуємо:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Wall_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;die&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;die&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Поки це нічого не виконуватиме, оскільки цього методу &lt;code&gt;die()&lt;/code&gt; у гравця поки немає. Але ми до цього дійдемо.&lt;/p&gt;
&lt;p&gt;Оскільки нам потрібні дві труби, одна над одною, то зараз, коли вже й сигнал під&amp;rsquo;єднано, дублюємо вузол &lt;code&gt;Wall&lt;/code&gt; (виділяємо в ієрархії та натискаємо &lt;code&gt;Ctrl&lt;/code&gt;+ &lt;code&gt;D&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для нової труби в інспекторі в секції &lt;code&gt;Transform&lt;/code&gt; для &lt;code&gt;Scale&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; виставляємо -1, що віддзеркалить трубу по вертикалі. А далі позицію по &lt;code&gt;y&lt;/code&gt; міняємо на -75.
Тепер обидві труби рівновіддалені від центру сцени. Але змістимо і центр сцени вниз, так щоб він був посередині екрану. Тобто, для вузла &lt;code&gt;Obstacle&lt;/code&gt; позицію по вертикалі задаємо 427, що якраз посередині нашого екрану гри.&lt;/p&gt;
&lt;p&gt;Нам ще потрібна буде секція, яка буде зараховувати, що гравець успішно пролетів перешкоду. Це теж буде вузол &lt;code&gt;Area2D&lt;/code&gt;. Створюємо його та назвемо &lt;code&gt;Score&lt;/code&gt;. До нього додаємо &lt;code&gt;CollisionShape2D&lt;/code&gt;, як завжди. А той визначаємо як прямокутник та прилаштовуємо, щоб він займав секцію посередині між трубами. По ширині він може бути трохи вужчим, ніж ширина труби.&lt;/p&gt;
&lt;p&gt;Для вузла &lt;code&gt;Score&lt;/code&gt; з&amp;rsquo;єднуємо сигнал з &lt;code&gt;Obstacle&lt;/code&gt;, але цього разу нас цікавить сигнал по виходу, а не по входу. Тож з&amp;rsquo;єднуємо сигнал &lt;code&gt;body_exited&lt;/code&gt;.
В новій функції робимо все ту ж перевірку, чи це саме гравець. Що саме буде викликатись, ми додамо пізніше. Поки залишимо порожню операцію.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Score_body_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Далі реалізуємо рух перешкоди. Для початку створимо глобальну змінну, що зберігатиме швидкість руху.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Створимо функцію &lt;code&gt;_process(delta)&lt;/code&gt;, це та, яка виконується для кожного кадру промалювання. Ми могли б використати фізичний цикл, але тоді анімація прокрутки землі може розсинхронізуватись з рухом перешкод і будуть помітні посмикування. По замовчуванню анімація прив&amp;rsquo;язана до циклу промалювання, хоч є можливість це змінити. Але ми підемо цим шляхом.&lt;/p&gt;
&lt;p&gt;Тож, нам потрібно циклічно зміщувати позицію перешкоди вліво. Також нам потрібний спосіб знищити перешкоду, коли вона вийшла з зони видимості. Інакше таких перешкод буде все більше і попри те, що їх не видно, на їх рух буде затрачатись ресурс. Для видалення ми перевірятимемо, чи глобальна позиція по горизонталі менша за величину -200.
Отже, у нас має получитись щось таке:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;queue_free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ви бачите там функцію &lt;code&gt;queue_free()&lt;/code&gt;. Це такий чемний спосіб попросити якийсь вузол разом з усіма його дочірніми елементами видалитись зі сцени. Цей варіант видалення виконується в кінці кадру, коли всі потенційні дії чи методи пов&amp;rsquo;язані з вузлом виконано.
Є також інший спосіб це зробити, функція &lt;code&gt;free()&lt;/code&gt;. Вона видаляє вузол миттєво, не чикаючи кінця кадру. Але це може привести до того, що якийсь метод пов&amp;rsquo;язаний з вузлом, що ми видаляємо, повисне і не буде завершено, що поламає виконання коду гри.&lt;/p&gt;
&lt;p&gt;Також процес видалення вузлів зі сцени може викликати інші помилки, які варто враховувати. Але їх ми розглянемо в наступних проектах.&lt;/p&gt;
&lt;p&gt;Тож, ми маємо певну структуру, що являє собою перешкоду. Судячи з коду, вона повинна рухатись. Але поки у нас немає можливості її перевірити.
Спробуємо це зробити. Зберігаємо всі зміни та переходимо до сцени &lt;code&gt;Main&lt;/code&gt;. Тут ми можемо просто розмістити один екземпляр перешкоди та перемістити її на праву сторону екрану.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyTestObst&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyTestObst&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

</description>
        </item>
        <item>
        <title>7. Генератор перешкод</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_generator/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_generator/</guid>
        <description>&lt;h1 id=&#34;генератор-перешкод&#34;&gt;Генератор перешкод
&lt;/h1&gt;&lt;p&gt;По завершенню попереднього розділу ми вставили перешкоду в головну сцену. Перешкода проїхала повз гравця і зникла. Тільки от нам треба, щоб таких перешкод було багато. В цьому розділі ми організуємо масове виробництво перешкод і почнемо з того, що видалимо ту, яку щойно вставили.&lt;/p&gt;
&lt;p&gt;Далі додаємо в головну сцену до вузла &lt;code&gt;Main&lt;/code&gt; новий вузол класу &lt;code&gt;Node2D&lt;/code&gt;. Називаємо новий вузол &lt;code&gt;ObstacleSpawner&lt;/code&gt;. До нього відразу приєднуємо новий порожній сценарій.&lt;/p&gt;
&lt;p&gt;До цього генератора додаємо новий вузол &lt;code&gt;Timer&lt;/code&gt;. Це дуже проста річ. Вона вміє відраховувати визначену кількість часу, а коли дійде до нуля, посилає сигнал про це. Такий таймер можна налаштувати відпрацьовувати циклічно. Ми його будемо використовувати, щоб рівномірно відраховувати час на генерацію перешкод.
В параметрах таймера в інспекторі визначаємо величину &lt;code&gt;Wait Time&lt;/code&gt; в значення 1.5 секунди. Далі переходимо в вкладку &lt;code&gt;Node&lt;/code&gt; та під&amp;rsquo;єднуємо сигнал &lt;code&gt;timeout()&lt;/code&gt; до вузла &lt;code&gt;ObstacleSpawner&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ми починаємо роботу над кодом для &lt;code&gt;ObstacleSpawner&lt;/code&gt;. У нас вже є під&amp;rsquo;єднаний сигнал таймера. Там пізніше ми допишемо виклик генерації перешкоди. Але для початку треба вказати, де брати цю саму перешкоду. Робимо нову змінну яка міститиме ресурс перешкоди. Для завантаження ресурсу існує спеціальна функція &lt;code&gt;preload()&lt;/code&gt;, яка бере як параметр шлях до необхідного файлу в межах проекту. Шлях може бути в форматі &lt;code&gt;&amp;quot;res://env/Obstacle.tscn&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;res://&lt;/code&gt; на початку адреси і служить вказівником на те, що ресурс є частиною проекту. Файл який нас цікавить, це файл сцени, а отже має розширення &lt;code&gt;.tscn&lt;/code&gt;
Автодоповнення запропонує вам варіанти файлів, серед яких ви знайдете потрібний.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappePreload&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappePreload&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Також необхідний файл можна затягнути в код, і його адресу буде додано автоматично.
Далі в коді ми будемо мати справу з генератором випадкових чисел. Нагадую, що в такому випадку десь на початку варто викликати &lt;code&gt;randomize()&lt;/code&gt;. Для цього додамо функцію &lt;code&gt;_ready()&lt;/code&gt; і отримаємо:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;randomize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Створюємо нову функцію &lt;code&gt;spawn_obsticale()&lt;/code&gt;. В цій функції створюємо змінну, в яку генеруємо екземпляр перешкоди і відразу додаємо цей екземпляр як дочірній до вузла &lt;code&gt;ObstacleSpawner&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;spawn_obsticale&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obstical_obj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Obsticale&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;add_child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obstical_obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Далі нам потрібно задати випадкову позицію для перешкоди по вертикалі. Ми зробимо так, щоб діапазон позицій міг коливатись в межах 400 пікселів та ніколи не піднімався ближче 150 пікселів від верху екрану. Для цього спочатку генеруємо випадкове число з плаваючею точкою. Це дасть нам будь-яке значення між 0.0 та 1.0. Домножуємо це число на 400, що вже дасть нам відхилення між 0.0 та 400.0. А далі просто додаємо відхилення в 150 пікселів.
У нас має вийти щось таке:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;obstical_obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;randf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;400.0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;150.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Тепер в функції &lt;code&gt;_on_Timer_timeout()&lt;/code&gt;, яка викликається по події завершення відрахунку таймером, додаємо виклик функції генератора &lt;code&gt;spawn_obsticale()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Ми ще не стартували таймер. Відлік часу для генерації не розпочинався. Нам буде потрібно спосіб розпочати цей відлік, так і спосіб його зупинити, на випадок зіткнення.
Додаємо дві дуже прості функції:&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$Timer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$Timer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
Пізніше виклик цих функцій буде додано до кореневого вузла, щоб звідти ми могли всім цим процесом управляти. Але зараз нам просто треба перевірити, чи все працює як ми замислили. Тож, додаємо виклик функції &lt;code&gt;start()&lt;/code&gt; до &lt;code&gt;_ready()&lt;/code&gt;.
Спробуємо гру.
Зверніть увагу, що перешкоди з&amp;rsquo;являються, але відразу по ліву сторону екрану. Це легко виправити. Виділяємо вузол &lt;code&gt;ObstacleSpawner&lt;/code&gt; та в інспекторі в розділі &lt;code&gt;Transform&lt;/code&gt; змінюємо його позицію по осі &lt;code&gt;x&lt;/code&gt; на десь поза екраном. Нагадаю, що ширина екрану у нас 480 пікселів. Тож, позиція 650 даватиме достатньо часу гравцю, щоб приготуватись до першої перешкоди.&lt;/p&gt;
&lt;p&gt;Спробуємо ще раз:&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyTest1&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyTest1&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Дві речі кидаються в очі&amp;hellip; По перше, перешкоди знаходяться попереду землі. Це легко виправити, просто перетягнувши вузол &lt;code&gt;ObstacleSpawner&lt;/code&gt; в ієрархії сцени вище вузла &lt;code&gt;Player&lt;/code&gt;. Друге, це те, що земля рухається повільніше, ніж перешкоди. Але якщо ми хотіли імітувати паралакс, то об&amp;rsquo;єкт, який знаходиться ближче, повинен рухатись швидше. Для того, щоб виправити ситуацію, виділяємо вузол &lt;code&gt;AnimationPlayer&lt;/code&gt; всередині &lt;code&gt;Ground&lt;/code&gt; та шукаємо в інспекторі параметр &lt;code&gt;Speed&lt;/code&gt; в розділі &lt;code&gt;Playback Options&lt;/code&gt;. Ця величина визначає швидкість відтворення анімації. Для цього випадку достатньо виставити значення &lt;code&gt;1.8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Зараз якщо ми запустимо, все рухається саме так, як того вимагається.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyTest2&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyTest2&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

</description>
        </item>
        <item>
        <title>8. Зіткнення з перешкодами</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_collision/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/obstacle_collision/</guid>
        <description>&lt;h1 id=&#34;зіткнення-з-перешкодами&#34;&gt;Зіткнення з перешкодами
&lt;/h1&gt;&lt;p&gt;Ми уже маємо опрацювання сигналів про зіткнення. Але далі цього пункту поки не пішли. Після зіткнення повинен виконатись цілий комплекс подій. Частина з них опрацьовується в коді гравця. А частина повинна опрацьовуватись центральним вузлом, як то, підрахунок балів, зупинка руху перешкод та анімації, вивід на екран панелі з повідомленням про здобутий рахунок.
Отже, нам треба якимось чином зв&amp;rsquo;язати подію смерті всередині гравця та кореневого вузла. Для цього можна створити спеціальний сигнал, який буде працювати подібно сигналам зіткнення з &lt;code&gt;Area2D&lt;/code&gt;, що ми вже неодноразово під&amp;rsquo;єднували. Але ми зробимо дещо інше. Ми викличемо публічний метод для &lt;code&gt;Main&lt;/code&gt;. Але для цього вузол гравця має знати, до кого звертатись. Сцена гри може мати різну структуру. Але ми домовляємось, що кореневий вузол залишається ключем в цій події. А корінь знайти легко, навіть не зважаючи, яку назву ми йому дамо.
Переходимо в код &lt;code&gt;Player&lt;/code&gt; та створюємо нову глобальну змінну, яка триматиме посилання на кореневий вузол.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;onready&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main_node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;get_root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;get_child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ми ініціювали цю змінну відразу, як вузол був до цього готовий і передали їй нульовий дочірній елемент для &lt;code&gt;get_tree().get_root()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ця конструкція, &lt;code&gt;get_tree().get_root()&lt;/code&gt; дає доступ до віртуального кореня сцени, поверх якого додається все те, що ми формуємо в сцені гри.
Якщо запустити гру, то в ієрархії зліва ви побачите цей корінь, а вже в ньому все те, що ми додали.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/scene_root.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Image&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Тож, таким нехитрим способом будь-який вузол може дізнатись хто виступає кореневим. Тоді кореневий зручно використовувати як такий собі регулювальник подій.&lt;/p&gt;
&lt;p&gt;Повертаємось в код гравця і створюємо нову логічну змінну, яка зберігатиме значення чи гравець все ще живий.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ще раз глянемо в код &lt;code&gt;Obstacle&lt;/code&gt; на хвилинку. Згадаємо, що ми там вже зробили. Ми маємо дві функції, одна з яких повинна викликати смерть, друга зарахування рахунку. Очікується, що об&amp;rsquo;єкт, який зіткнувся, тобто гравець, має методи &lt;code&gt;die()&lt;/code&gt; та &lt;code&gt;score()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Отже, вертаємось ще раз до коду гравця та створюємо нову функцію під назвою &lt;code&gt;die()&lt;/code&gt;. В цій функції першим ділом перевіряємо, а чи ми досі живі. Якщо ні, просто повертаємось з функції без жодної дії. Немає сенсу двічі поспіль помирати.
А якщо ж ні, якщо ми досі живі, тоді пора помирати. Тобто, змінюємо значення &lt;code&gt;alive&lt;/code&gt; на &lt;code&gt;false&lt;/code&gt;. Також в цій функції зупинимо анімацію.
Тож, отримаємо таку функцію:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;die&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Але цього не достатньо. У гравця все ще не відібрано управління. Для цього повертаємось до &lt;code&gt;_physics_process(delta)&lt;/code&gt;. Там у нас першим рядком відбувається перевірка, чи відбулась дія &lt;code&gt;flap&lt;/code&gt;, тобто натискання лівої клавіші мишки. Розширимо перевірку. Тепер нам треба, щоб відбулась і подія натискання, і птах залишався ще живим. Отримуємо:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;flap&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Якщо ви спробуєте зараз гру, то після зіткнення з перешкодою птах перестає бути контрольованим і падає вниз.
Нам ще потрібно вивести на екран повідомлення, про те, що гру програно. Цим буде займатись кореневий вузол &lt;code&gt;Main&lt;/code&gt;. Виділяємо вузол &lt;code&gt;Main&lt;/code&gt; та створюємо для нього новий порожній сценарій. Там створюємо функцію &lt;code&gt;game_over()&lt;/code&gt;. Поки що вона буде тільки виводити повідомлення в консоль.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;game_over&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Game Over!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Повертаємось до коду гравця, і в функції &lt;code&gt;die()&lt;/code&gt; викликаємо метод для завершення гри, що ми щойно створили. У нас уже є змінна &lt;code&gt;main_node&lt;/code&gt; яка зберігає посилання на кореневий вузол. Тож в кінець функції &lt;code&gt;die()&lt;/code&gt; дописуємо
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;main_node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;game_over&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Спробуйте зараз гру. Після зіткнення в консолі повинно з&amp;rsquo;явитись повідомлення &lt;code&gt;Game Over!&lt;/code&gt;. А також управління птахом припинено.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyFirstDie&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyFirstDie&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Але анімація фону і генерація перешкод продовжується. Для того, щоб це виправити, повертаємось в код &lt;code&gt;Main&lt;/code&gt; де ми будемо доповнювати функцію &lt;code&gt;game_over()&lt;/code&gt;.
Для початку зупинимо генерацію нових перешкод. Для цього в функцію &lt;code&gt;game_over()&lt;/code&gt; додаємо виклик методу &lt;code&gt;stop()&lt;/code&gt; для об&amp;rsquo;єкту &lt;code&gt;ObstacleSpawner&lt;/code&gt;.
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$ObstacleSpawner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Ми цей метод уже створили. Усе що він робить, це зупиняє таймер, за яким відбувається генерація перешкод. Але він не зупиняє рух самих перешкод.
Щоб зупинити рух, переходимо до коду &lt;code&gt;ObstacleSpawner&lt;/code&gt; та створюємо нову функцію &lt;code&gt;stop_movement()&lt;/code&gt;. Ця функція буде перебирати усі дочірні об&amp;rsquo;єкти, а це і є наші перешкоди, і викликатиме для них метод для зупинки їх руху.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop_movement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_children&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Цього методу &lt;code&gt;stop()&lt;/code&gt; для самих перешкод ми поки не створили. Переходимо до коду перешкоди та додаємо дуже простий метод:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Повертаємось знову до коду &lt;code&gt;Main&lt;/code&gt; та додаємо виклик цього усього в один рядок&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$ObstacleSpawner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop_movement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Спробуємо ще раз гру:&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappySecondDie&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappySecondDie&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Залишилось зупинити рух землі. Для цього додаємо ще один рядок:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$Ground/AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;Flappy3Die&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;Flappy3Die&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;В наступному розділі ми оформимо панель з повідомленням та кнопку для повторної спроби.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>9. Зіткнення з землею</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/ground_collision/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/ground_collision/</guid>
        <description>&lt;h1 id=&#34;зіткнення-з-землею&#34;&gt;Зіткнення з землею
&lt;/h1&gt;&lt;p&gt;Ми уже реалізували зіткнення з трубами та наслідки для гравця в результаті цих зіткнень. Залишається ще одна перешкода, яка має викликати ті самі наслідки. А саме, земля. Поки поверхню землі представляв об&amp;rsquo;єкт класу &lt;code&gt;StatycBady2D&lt;/code&gt;. Тобто, статичний об&amp;rsquo;єкт, що має форму прямокутника, представлену колайдером, який вкриває нижню частину екрану.&lt;/p&gt;
&lt;p&gt;Але за умовами гри, після зіткнення з землею птах теж має помирати. Діло лише у тому, що &lt;code&gt;StatycBady2D&lt;/code&gt; не може надсилати жодних сигналів в результаті зіткнення. Він функціонує лише як примітивна стінка. Тому нам потрібно додати ще один, уже добре знайомий нам об&amp;rsquo;єкт, а саме, &lt;code&gt;Area2D&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для об&amp;rsquo;єкту &lt;code&gt;Ground&lt;/code&gt; додаємо новий дочірній класу &lt;code&gt;Area2D&lt;/code&gt;. Колайдер можемо здублювати той, що у &lt;code&gt;Ground&lt;/code&gt;. Просто виділяємо його на панелі сцени, та натискаємо &lt;code&gt;Ctrl+D&lt;/code&gt;. Перетягуємо нову копію в &lt;code&gt;Area2D&lt;/code&gt;, та зовсім трошки переміщаємо вгору, так щоб цей колайдер реагував на зіткнення зовсім трохи раніше. Перемістити можна стрілкою вгору на клавіатурі, попередньо для цього переконатись, що потрібний нам колайдер виділено, тоді перевести мишку у центральну частину вікна &lt;code&gt;2D&lt;/code&gt;, та натиснути стрілку кілька разів.&lt;/p&gt;
&lt;p&gt;Перейменуємо об&amp;rsquo;єкт &lt;code&gt;Area2D&lt;/code&gt; на &lt;code&gt;GroundCollision&lt;/code&gt;, щоб ми не плутались.
Для нього буде потрібно трошки коду, де він буде реагувати на зіткнення. Тож, створюємо для вузла &lt;code&gt;GroundCollision&lt;/code&gt; порожній код. Для знову виділяємо сам вузол &lt;code&gt;GroundCollision&lt;/code&gt; та на  правій панелі, там де інспектор, переходимо на вкладку &lt;code&gt;Node&lt;/code&gt;, та двічі клацаємо на сигналі &lt;code&gt;body_entered()&lt;/code&gt;, та під&amp;rsquo;єднаємо до самого вузла &lt;code&gt;GroundCollision&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ця функція має мати усе те саме, що було в функції зіткнення з перешкодою. Тож, виглядати вона буде таким чином:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_GroundCollision_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;die&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;die&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Перевірте, чи вона працює.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>10. Виведення рахунку</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/score/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/score/</guid>
        <description>&lt;h1 id=&#34;виведення-рахунку&#34;&gt;Виведення рахунку
&lt;/h1&gt;&lt;p&gt;Наша гра більш-менш прийняла свою форму. Але досі ми не створювали ніякого інтерфейсу, панелей, кнопок, меню і тому подібного. Цього разу ми створимо вузол, що міститиме усе, що стосується інтерфейсу, а також додамо вивід рахунку гри.
Почнемо зі створення нового вузла як дочірнього до &lt;code&gt;Main&lt;/code&gt; в сцені &lt;code&gt;Main&lt;/code&gt;. Цей вузол буде класу &lt;code&gt;CanvasLayer&lt;/code&gt;. Цей клас призначений для того, щоб уміщати елементи інтерфейсу, та відповідно їх відображати під час гри. Перейменуємо цей новий вузол на &lt;code&gt;HUD&lt;/code&gt;, що розшифровується як &amp;ldquo;heads-up display&amp;rdquo;. Так часто називають графічний інтерфейс користувача в іграх. Тут ми будемо відображати як рахунок під-час гри, так і спеціальну панель після програшу.
Першим елементом буде рахунок під час гри. Це буде простий текстовий елемент, що відображатиметься вгорі екрану. Великі білі цифри. Переходимо в розділ &lt;code&gt;2D&lt;/code&gt;, щоб ми бачили, що робимо, та до вузла &lt;code&gt;HUD&lt;/code&gt; додаємо новий вузол типу &lt;code&gt;Label&lt;/code&gt;. Перейменовуємо його в &lt;code&gt;Score&lt;/code&gt; та обираємо компонування (&lt;code&gt;Layout&lt;/code&gt;) - &lt;code&gt;Top Wide&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyTopWide&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyTopWide&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Шрифт, який ввімкнено за замовчуванням є дуже маленьким і не підходить до нашої задачі. Нам потрібен шрифт з великими літерами, що легко читаються. Почнемо з того, до в інспекторі для нашого об&amp;rsquo;єкта &lt;code&gt;Score&lt;/code&gt; в полі &lt;code&gt;Text&lt;/code&gt; напишемо якісь цифри, щоб бачити зміни, які ми вносимо в відображення рахунку. Текст, як я уже говорив, виходить дуже малий, але він ще й зміщений в ліву сторону. Щоб це виправити, міняємо значення параметру &lt;code&gt;Align&lt;/code&gt; на значення &lt;code&gt;Center&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Далі переходимо в розділ &lt;code&gt;Theme Overrides&lt;/code&gt;. тут ми будемо створювати новий шрифт. В розділі &lt;code&gt;Fonts&lt;/code&gt; натискаємо на кнопку де написано &lt;code&gt;Empty&lt;/code&gt; та обираємо &lt;code&gt;New DynamicFont&lt;/code&gt;. Натискаємо ще раз на цю клавішу, щоб розгорнути параметри нового генератора динамічних шрифтів. Там теж є розділ &lt;code&gt;Font&lt;/code&gt;. Обираємо &lt;code&gt;New DynamicFontData&lt;/code&gt;. Після створення, розгортаємо. Тут у нас є параметр &lt;code&gt;Font Path&lt;/code&gt;. Натискаємо на кнопку з іконкою теки, та шукаємо доданий до проекту шрифт, що розташований в &lt;code&gt;fonts/SpaceGrotesk-Bold.otf&lt;/code&gt;. Останнє, що потрібно зробити, це трохи вище знайти розділ &lt;code&gt;Settings&lt;/code&gt;, розгорнути його та змінити значення &lt;code&gt;size&lt;/code&gt; на 64.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyNewFont&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyNewFont&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Щоб можна було повторно використати усі ці самі налаштування тане робити це ще раз, вище, де параметр &lt;code&gt;Font&lt;/code&gt;, навпроти параметру &lt;code&gt;DynamicFont&lt;/code&gt; натискаємо клавішу зі стрілочкою вниз та обираємо &lt;code&gt;Save&lt;/code&gt;. Зберігаємо в каталозі &lt;code&gt;Fonts&lt;/code&gt; під назвою &lt;code&gt;score_font&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyScoreFont&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyScoreFont&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Ми можемо відразу причепити функціонал до цього тексту, та виводити рахунок по мірі гри. Для цього, переходимо до коду &lt;code&gt;Main&lt;/code&gt;. Там створюємо нову змінну &lt;code&gt;score = 0&lt;/code&gt;. Далі створюємо функцію &lt;code&gt;add_score()&lt;/code&gt; а в ній пишемо:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;score&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;update_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Функція, яка відповідає за вивід рахунку буде окремою (&lt;code&gt;update_score()&lt;/code&gt;), що дозволить нам оновити рахунок на екрані ще до того, як гравець здобуде перший бал. Ось її код:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;$HUD/Score&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Погляньте в код &lt;code&gt;Obstacle&lt;/code&gt;. Там у нас було:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Score_body_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;score&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ця функція викликається сигналом від колайдера між труб. Вона повинна викликати метод &lt;code&gt;score()&lt;/code&gt; в тілі гравця. Переходимо знову до коду &lt;code&gt;Player&lt;/code&gt; та створюємо функцію &lt;code&gt;score()&lt;/code&gt; де викликаємо однойменний метод з &lt;code&gt;main_node&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;main_node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Для виводу рахунку залишилась одна дрібниця. На початку, до того, як гравець здобув перший бал ми усе ще бачимо цифри &lt;code&gt;123&lt;/code&gt; які ввели для тестування. Цей текст можна відредагувати там само, але ми змінимо виведене значення на старті гри. Для цього створимо в &lt;code&gt;Main&lt;/code&gt; функцію &lt;code&gt;_ready()&lt;/code&gt;, яка автоматично викликається на початку гри і допишемо туди один рядок:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;update_score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
        </item>
        <item>
        <title>11. Панель Game Over</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/game_over_panel/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/game_over_panel/</guid>
        <description>&lt;h1 id=&#34;панель-game-over&#34;&gt;Панель Game Over
&lt;/h1&gt;&lt;p&gt;Продовжимо роботу з інтерфейсом. Цього разу ми створимо панель, що з&amp;rsquo;являтиметься після програшу.&lt;br&gt;
3ентральним елементом буде вузол &lt;code&gt;NinePatchRect&lt;/code&gt;. Тож, до вузла &lt;code&gt;HUD&lt;/code&gt; додаємо новий &lt;code&gt;NinePatchRect&lt;/code&gt;. Текстурою для нього обираємо зображення під назвою &lt;code&gt;score_panel.png&lt;/code&gt; в каталозі &lt;code&gt;sprites&lt;/code&gt;. В інспекторі переходимо в розділ &lt;code&gt;Rect&lt;/code&gt;, там змінюємо значення &lt;code&gt;Size&lt;/code&gt; на величини 370 на 200. Вгорі екрану шукаємо кнопку &lt;code&gt;Layout&lt;/code&gt; та обираємо &lt;code&gt;Center&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Наступний елемент, ще один текст, що відображатиме фінальний рахунок. Для цього можемо зробити копію того текстового елементу, що ми уже маємо. Виділяємо на лівій панелі елемент &lt;code&gt;Score&lt;/code&gt; та натискаємо комбінацію &lt;code&gt;Ctrl + D&lt;/code&gt;, щоб отримати дублікат. Цю нову копію переносимо всередину вузла &lt;code&gt;NinePatchRect&lt;/code&gt;. Далі вгорі з меню &lt;code&gt;Layout&lt;/code&gt; обираємо &lt;code&gt;HCenter Wide&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Стрілкою вниз на клавіатурі трохи змістимо текстовий елемент вниз, так щоб його нижній край торкався до темної частини зображення. Поправимо ім&amp;rsquo;я цього елементу, щоб воно теж було &lt;code&gt;Score&lt;/code&gt;. Далі швиденько стрибнемо в код &lt;code&gt;Main&lt;/code&gt; та в функцію &lt;code&gt;update_score()&lt;/code&gt; додамо рядок:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$HUD/NinePatchRect/Score&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Так обидва текстові елементи будуть оновлюватись одночасно.&lt;br&gt;
Ще раз здублюємо елемент &lt;code&gt;Score&lt;/code&gt; з яким ми щойно працювали на стрілкою вгору на клавіатурі змістимо нову копію вгору, так щоб вона зайняла верхню частину панелі. Змінимо текст на &lt;code&gt;score:&lt;/code&gt;. Прогорнемо інспектор в самий низ в розділ &lt;code&gt;Visibility&lt;/code&gt; та змінимо колір &lt;code&gt;Modulate&lt;/code&gt; на чорний.&lt;/p&gt;
&lt;p&gt;Нам залишилось додати кнопку рестарту гри.&lt;/p&gt;
&lt;p&gt;До вузла &lt;code&gt;NinePatchRect&lt;/code&gt; додаємо новий вузол &lt;code&gt;TextureButton&lt;/code&gt;. Це такий тип кнопки, яка може мати кілька текстур на різні події. Перейменовуємо кнопку на &lt;code&gt;RestartButton&lt;/code&gt;. В інспекторі розгортаємо розділ &lt;code&gt;Textures&lt;/code&gt;. В параметр &lt;code&gt;Normal&lt;/code&gt; втягуємо зображення з ім&amp;rsquo;ям &lt;code&gt;restart_button.png&lt;/code&gt;, а в параметр &lt;code&gt;Pressed&lt;/code&gt; текстуру &lt;code&gt;restart_button_pressed.png&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;За замовчуванням розмір клавіші відповідає розміру зображення. Наше зображення трохи великувате. Тому гортаємо в самий верх інспектора та виставляємо галочку &lt;code&gt;Expend&lt;/code&gt; а також міняємо параметр &lt;code&gt;Stratch mode&lt;/code&gt; на &lt;code&gt;Keep Aspect Centered&lt;/code&gt;, що забезпечить збереження пропорцій кнопки, не залежно від того, як ми її розтягнемо.&lt;/p&gt;
&lt;p&gt;Далі опускаємось в розділ &lt;code&gt;Rect&lt;/code&gt; та міняємо &lt;code&gt;Size&lt;/code&gt; на 300 x 120. В меню &lt;code&gt;Layout&lt;/code&gt; обираємо &lt;code&gt;Center Bottom&lt;/code&gt;, після чого ще зміщуємо кнопку вниз стрілками, поки вона не стане на кілька пікселів нижче панелі.&lt;/p&gt;
&lt;p&gt;Залишилось приєднати якусь дію по натисканню кнопки. Виділяємо кнопку на на правій панелі, там де інспектор переходимо на вкладку &lt;code&gt;Node&lt;/code&gt; вгорі. Ми маємо бачити список доступних сигналів. Оберемо сигнал &lt;code&gt;pressed()&lt;/code&gt;, який надсилає сигнал після повного натискання кнопки. Подвійне натискання на цьому сигналі, та обираємо вузол &lt;code&gt;Main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Це можна зробити різними способами, але щоб розпочати нову гру, ми додамо лише один рядок до нової функції, а саме:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;get_tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;reload_current_scene&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Ця функція, як випливає з назви, робить повний рестарт сцени, в якій ми знаходимось в момент її виконання. Це дозволить нам без особливих затрат розпочати нову спробу.&lt;/p&gt;
&lt;p&gt;Залишилась ще одна проблема. Нова панель поверх гри, і заважає грати. Вона повинна з&amp;rsquo;являтись тільки після того, як ми програли.&lt;/p&gt;
&lt;p&gt;Виділяємо вузол &lt;code&gt;NinePatchRect&lt;/code&gt; на натискаємо маленьку кнопку з оком, навпроти імені вузла. Це приховає вузол. Залишається тільки знову його показати, коли ми програли. Для цього повертаємось в код &lt;code&gt;Main&lt;/code&gt; та в нашу функцію &lt;code&gt;game_over()&lt;/code&gt; додаємо рядок:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$HUD/NinePatchRect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;visible&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Залишилось ще трохи додати краси, і наша гра практично готова.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>12. Анімований фон</title>
        <link>http://localhost:1313/docs/godot_pong/flappy_bird/animated_skyline/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://localhost:1313/docs/godot_pong/flappy_bird/animated_skyline/</guid>
        <description>&lt;h1 id=&#34;анімований-фон&#34;&gt;Анімований фон
&lt;/h1&gt;&lt;p&gt;Ми уже маємо гру, яку можна грати і отримувати задоволення. У цьому розділі ми їй лише додамо трохи краси. Те, що у нас має вийти, це кілька шарів фону, що рухаються кожен зі своєю швидкістю, створюючи ілюзію глибини. Для цього є кілька заготовлених текстур. І процес їх анімації мало чим відрізнятиметься від анімації поверхні землі під птахом.&lt;/p&gt;
&lt;p&gt;Почнемо з створення вузла, що триматиме усі шари фону. Виділяємо вузол &lt;code&gt;Main&lt;/code&gt; та додаємо до нього звичайний &lt;code&gt;Node2D&lt;/code&gt;. Перейменовуємо його на &lt;code&gt;Background&lt;/code&gt;. В ієрархії сцени перемістимо так, щоб він був розташований одразу під об&amp;rsquo;єктом &lt;code&gt;Sky&lt;/code&gt;. Тобто, малювався поверх неба, та позаду усього іншого.&lt;/p&gt;
&lt;p&gt;До цього вузла створюємо ще один &lt;code&gt;Node2D&lt;/code&gt;. Це нам трохи спростить роботу в подальшому. Цей новий вузол називаємо &lt;code&gt;Forest1&lt;/code&gt;. До нього додаємо вузол &lt;code&gt;Sprite&lt;/code&gt; Та перейменовуємо в &lt;code&gt;ForestSprite1&lt;/code&gt;.
В параметр &lt;code&gt;Texture&lt;/code&gt; втягуємо зображення &lt;code&gt;forest01.png&lt;/code&gt;. В розділі &lt;code&gt;Offset&lt;/code&gt; зніміть галочку &lt;code&gt;Centered&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для наших цілей потрібно дві копії цієї самої текстури, тому дублюємо вузол. Для цього переконаємось, що він виділений в ієрархії сцени, та натискаємо &lt;code&gt;Ctrl+D&lt;/code&gt;. Нову копію в ієрархії перетягуємо так, щоб вона стала дочірньою до оригіналу. Також копію треба перемістити ліворуч. Для цього виділяємо її, переходимо в інспекторі в розділ &lt;code&gt;Transform&lt;/code&gt; та змінюємо значення позиції по осі &lt;code&gt;x&lt;/code&gt; на 512 (це ширина зображення яке ми використовуємо). Ще раз переконуємось, що об&amp;rsquo;єкт &lt;code&gt;ForestSprite2&lt;/code&gt; виділено, та на верхній панелі натискаємо на кнопку з замочком, щоб ми випадково його не перемістили. Так само робимо для вузла &lt;code&gt;ForestSprite1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Виділяємо вузол &lt;code&gt;Forest1&lt;/code&gt;, вмикаємо інструмент переміщення та з затиснутою клавішею &lt;code&gt;Ctrl&lt;/code&gt; перетягуємо вниз, доти, поки він на кілька пікселів не сховається за землею. До об&amp;rsquo;єкту &lt;code&gt;Forest1&lt;/code&gt; додаємо новий вузол &lt;code&gt;AnimationPlayer&lt;/code&gt;. Там створюємо нову анімацію під назвою &lt;code&gt;scroll&lt;/code&gt;. Довжина анімації повинна бути 3 секунди, вона має бути зациклена та стартувати автоматично.&lt;/p&gt;
&lt;p&gt;Перший ключ встановлюємо для вузла &lt;code&gt;ForestSprite1&lt;/code&gt; для параметру &lt;code&gt;Position&lt;/code&gt; в розділі &lt;code&gt;Transform&lt;/code&gt;. Перетягуємо бігунок часу на відмітку 3 секунди. Змінюємо значення позиції по осі &lt;code&gt;x&lt;/code&gt; для вузла &lt;code&gt;ForestSprite1&lt;/code&gt; на &lt;code&gt;-512&lt;/code&gt;. Ставимо ще один ключ.&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyForestAnim1&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyForestAnim1&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Ось що ми зараз побачимо в грі:&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyForestTest&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyForestTest&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Фон з лісом рухається саме так, як і вимагалось. Він не зупиняється після програшу, але це ми виправимо трохи пізніше.&lt;/p&gt;
&lt;p&gt;Наступним має бути ще один шар лісу. Дублюємо вузол &lt;code&gt;Forest1&lt;/code&gt;. В ієрархії перетягуємо так, щоб новий був позаду оригіналу. Далі стрілочкою вгору на клавіатурі підсуваємо його на трохи вище.
Далі для обох вкладених в нього спрайтів заміняємо текстури на &lt;code&gt;forest02.png&lt;/code&gt;. Залишилось його трохи сповільнити. Виділяємо вузол &lt;code&gt;AnimationPlayer&lt;/code&gt; всередині &lt;code&gt;Forest2&lt;/code&gt;. В інспекторі розгортаємо &lt;code&gt;Playback options&lt;/code&gt; та змінюємо значення &lt;code&gt;Speed&lt;/code&gt; на величину &lt;code&gt;0.9&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Щоб обидва ці елементи зупинялись, коли гравець програв, переходимо в код &lt;code&gt;Main&lt;/code&gt; та в кінець функції &lt;code&gt;game_over()&lt;/code&gt; додаємо два рядки:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-GDScript&#34; data-lang=&#34;GDScript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$Background/Forest1/AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;$Background/Forest2/AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;В каталозі &lt;code&gt;sprites&lt;/code&gt; є ще кілька заготовлених зображень з містом та хмарами. Усі ці елементи ви можете додати подібним чином самостійно. Тільки враховуйте, що їх розмір може відрізнятись, тому десь відступи будуть більшими і десь потрібно буде створити нову анімацію, оскільки ця, що ми уже створили підходить тільки якщо зображення має ширину 512 пікселів.&lt;/p&gt;
&lt;p&gt;Загалом, після усіх правок і деякої додаткової косметичної роботи, гра може виглядати таким чином:&lt;/p&gt;
&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;video
    controls
    src=&#34;FlappyFin&#34;
    
    autoplay
    &gt;
        &lt;p&gt;
            Your browser doesn&#39;t support HTML5 video. Here is a
            &lt;a href=&#34;FlappyFin&#34;&gt;link to the video&lt;/a&gt; instead.
        &lt;/p&gt;
    &lt;/video&gt;
&lt;/div&gt;

&lt;p&gt;Фінальну версію проекту можна завантажити тут:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://localhost:1313/download/flappy_fin.zip&#34; &gt;flappy_fin.zip&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
